2. a.
-  A brief overview of part a, is to create a Java program which takes an odd number, $n$,  from the user and creates a magic square with a length of $n$. A magic square can be formed of an $n*n$ matrix which contains the numbers from $1-n^2$, where the sum of each horizontal, vertical and diagonal line in the square is equal to $\frac{n(n^2+1)}{2}$. This program must then use a provided algorithm to find the coordinates of each number, where the goals are to: have the successful creation of these squares no matter the odd integer; efficiently create these squares and make sure that sufficient error handling is implemented. Then using this first part, the second part is to create a game using this. The game shuffles the previously made magic square and allows the user to swap the position of the numbers to try "*unshuffle*" said square, but when swapping numbers they must both have one equal coordinate, meaning they are vertical or horizontal neighbours. The goals for this section are to: correctly shuffle the square $n^2$ times; find a way to know when the user has won; ensure the user's input has error handling and the system correctly swaps the numbers, especially when wrapping around the square.

2. b.
- My solution to this problem includes multiple modular programs which all collaborate on the creation and logic of the magic square and its game. I assumed that humans are clumsy and will most definitely mess up the inputs, thus the "*InputHandler.java*" file, where it was assumed that the input handler mentioned is mainly used for the magic square game as there are multiple parameters that may not be useful in other game types. I then used the provided algorithm where I changed it to be a 0-based index instead of 1 (by decrementing the original x and y values), then displayed this on axis to not confuse the user. Also, I started by assuming that there is only one solution to each magic square, but realised that there is not therefore I created an algorithm which takes each row, column and diagonal and made sure they are equal to $\frac{n(n^2+1)}{2}$ else it is not solved.

2. c.
- The quality of my solution is well done as it includes many helpful aspects for testing and debugging such as modularity; well documented code through the use of comments and self explanatory variable and function names. Before creating a modular approach to the problem I started off using only one class and object, where I ran into a few problems with testing my code such as getting lost in the code and relying too much on instance variables. After making the transfer to a more modular code, I found that my function for seeing if the magic square is solved was not truly accurate this is due to me creating the same square once and only shuffling one and comparing the two after each move made by the user, This lead to a problem since there are a few ways to mathematically solve a magic square but not in my code therefore I rewrote the function for this to check the rows, columns and diagonal, where I realised for a while, was not working since I would add all the values in the whole square instead of the rows and columns individually thus it always equals the same as 3 times $\frac{n(n^2+1)}{2}$, this was how I check if the square was solved . Also, there was a strange bug I found where my code would randomly loop within the function where there was no loop, I found out was a while loop in my constructor class that I swiftly changed. Also when first trying to understand the given algorithm, to fill in the square, I made an assumption that the x and y variables corresponded to the x and y axis such as on a graph and that the algorithm was already 0-based indexed which was incorrect and took a few read throughs to truly understand without assumption.

2. d.
- My software test methodology was mainly focused on using the "*Waterfall Model*", which is a test methodology done step by step, first off with "*defining the requirements*" then "*creating the design*" followed by "*implementation of the code*" after this is "*the verification of the code*" finally is "*maintenance*", which would not be required for my solution once fully solved, as there are no changes made by any users to the original code. When designing my requirements I had them as such as this one,  "*a solution of the question which can handle user input errors and leads to a clear understanding of the game.*" After this is the design whereby I first tried to use a singular design which I found in the implementation section was not useful leading me back to the design section. I realised that a modular design would lead to many benefits such as those mentioned in part c. Then  after the implementation of this, using user testing and my own testing, led to finding bugs which were fixed and allowed more comprehensive error handling and a valid solution. 
